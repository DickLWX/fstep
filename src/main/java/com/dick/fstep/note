
sql 查询为Null 用List接收后list.size = 1 解决办法 把left join 改为 inner join
关于 “A LEFT JOIN B ON 条件表达式” 的一点提醒
ON条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从B表中检索数据行。
如果B表中没有任何一行数据匹配ON的条件,将会额外生成一行所有列为NULL的数据
在匹配阶段WHERE子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。



插入数据关注用户重复发同一个请求，导致数据库出现两条一样的数据，造成问题，解决方案，唯一索引加ON DUPLICATE KEY UPDATE

当前端传的是json 时间使用字符串传的，如果后台用date去接就会出错，此时可以用@JsonDeserialize 具体怎么搞可以百度

泛型中的 extend super https://www.cnblogs.com/lucky_dai/p/5485421.html

多线程 https://www.cnblogs.com/wxd0108/p/5479442.html  https://www.cnblogs.com/lwbqqyumidi/p/3804883.html(基础)
synchronized 需要注意的问题 当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，
使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心...

线程池 https://www.cnblogs.com/dolphin0520/p/3932921.html

数据库 https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect

学习 https://github.com/Snailclimb/JavaGuide

在向arraylist 添加大量元素前，如果添加元素的个数已知可以调用ensureCapacity方法，可以在加入元素之前将List扩容，减少的时间损耗

threadlocal 子线程不能取到父线程的threadlocal类的变量。inheritableThreadlocal可以解决这个问题 这个类还是有些坑，要慎用

nio http://www.importnew.com/19816.html






